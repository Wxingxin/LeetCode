# 题

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

## 示例 1:

输入: `numRows = 5`
输出: `[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]`

## 示例 2:

输入: `numRows = 1`
输出: `[[1]]`

# 解

这是 **LeetCode 118：杨辉三角**，也是一个非常经典、**非常适合练动态规划思维**的题目。

---

## 一、核心思路（动态规划视角）

### 状态定义

- `dp[i][j]`：表示 **第 i 行第 j 个数**（从 0 开始）

### 状态转移

- 每行的 **第一个和最后一个元素一定是 1**
- 其他位置：

```
dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
```

---

## 二、直接可用的 JavaScript 解法（推荐）

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function (numRows) {
  const result = [];

  for (let i = 0; i < numRows; i++) {
    // 创建第 i 行
    const row = new Array(i + 1).fill(1);

    // 计算中间的值
    for (let j = 1; j < i; j++) {
      row[j] = result[i - 1][j - 1] + result[i - 1][j];
    }

    result.push(row);
  }

  return result;
};
```

---

## 三、举个例子 🌰

输入：

```js
numRows = 5;
```

输出：

```js
[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]];
```

---

## 四、为什么这是动态规划？

虽然代码里没有显式写 `dp` 变量，但本质上：

```js
result[i][j] === dp[i][j];
```

满足 DP 的三要素：

1. ✅ **状态定义**：每个位置的值
2. ✅ **状态转移**：由上一行两个值相加
3. ✅ **子问题复用**：第 i 行依赖第 i-1 行

👉 和你刚才问的「爬楼梯没看到 dp」是 **同一个思想**

---

## 五、时间 & 空间复杂度

- **时间复杂度**：`O(numRows²)`
- **空间复杂度**：`O(numRows²)`（必须存所有行作为结果）

> ⚠️ 这里**不能像爬楼梯那样压缩到 O(1)**
> 因为题目要求返回 **整个三角形**

---

## 六、如果你想进一步进阶 🚀

我可以继续帮你：

- 改成 **只计算第 k 行（LeetCode 119）**
- 用 **一维数组** 实现状态压缩
- 从 **组合数学** 角度解释为什么是这样

你已经在用「DP 思维」看问题了，这是非常好的信号 👏
