# 题
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。

左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 "(()())"。

 

示例 1：

输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：

输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：

输入：s = ""
输出：0
# 解

这题（LeetCode 32）经典而且很“坑”，我用 **DP 解法**给你讲清楚：状态怎么定义、为什么这样转移、再给完整 JS 代码，并用例子手推一遍。

---

## DP 核心定义

令：

> `dp[i]` 表示：**以 `s[i]` 这个字符结尾的最长有效括号子串长度**

注意两个关键词：

* **必须连续**
* **必须以 i 结尾**（这点决定了转移方式）

显然：

* 如果 `s[i]` 是 `'('`，那不可能结尾形成有效括号 → `dp[i] = 0`
* 只有当 `s[i]` 是 `')'` 时才可能有值

---

## 状态转移（最关键）

当 `s[i] === ')'`，分两种情况：

### 情况 1：`...()` 直接配对

如果前一个字符是 `'('`，即 `s[i-1] === '('`
那么 `s[i-1..i]` 就是 `"()"`

此时：

* `dp[i] = dp[i-2] + 2`
* `dp[i-2]` 是为了把 `"()"` 前面那段有效括号拼上
* 注意 i-2 越界时当作 0

公式：

```
dp[i] = (i >= 2 ? dp[i-2] : 0) + 2
```

---

### 情况 2：`...))` 需要“跨越”去找匹配的 '('

如果 `s[i-1] === ')'`，比如 `"(...))"`
那么我们先看 `dp[i-1]`：它是以 i-1 结尾的最长有效长度。

设：

* `len = dp[i-1]`
* 那么有效段是 `s[i-len .. i-1]`
* 我们希望 `s[i-len-1]` 是 `'('` 来和 `s[i]` 这个 `')'` 配对

所以检查位置：

```
j = i - dp[i-1] - 1
```

如果 `j >= 0` 且 `s[j] === '('`，说明能闭合：

* 先加上当前配对的 `2`
* 再加上里面的 `dp[i-1]`
* 还要把 j 前面那段有效括号拼上：`dp[j-1]`

公式：

```
dp[i] = dp[i-1] + 2 + (j >= 1 ? dp[j-1] : 0)
```

---

## 完整 JS 代码（DP）

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    const n = s.length;
    const dp = new Array(n).fill(0);
    let ans = 0;

    for (let i = 1; i < n; i++) {
        if (s[i] === ')') {
            // 情况1：...()
            if (s[i - 1] === '(') {
                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
            } 
            // 情况2：...))
            else {
                const j = i - dp[i - 1] - 1; // 可能匹配的 '(' 的位置
                if (j >= 0 && s[j] === '(') {
                    dp[i] = dp[i - 1] + 2 + (j >= 1 ? dp[j - 1] : 0);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
    }

    return ans;
};
```

---

## 用示例 2 手推（`)()())`）

`s = ")()())"`
下标：0 1 2 3 4 5
字符：) ( ) ( ) )

`dp` 初始全 0，ans=0

* i=2，s[2]=')'，s[1]='(' → 情况1
  dp[2] = dp[0] + 2 = 2
  ans=2

* i=4，s[4]=')'，s[3]='(' → 情况1
  dp[4] = dp[2] + 2 = 4
  ans=4

* i=5，s[5]=')'，s[4]=')' → 情况2
  j = 5 - dp[4] - 1 = 5 - 4 - 1 = 0
  s[0]=')' 不是 '(' → dp[5]=0
  ans仍为4

最终 ans=4 ✅（对应 "()()"）

---

## 为什么这个 DP 很妙？

因为“连续子串”要求非常强：
你不能随便匹配，需要确保**以 i 结尾**时，能把前面的有效段“拼接起来”，DP 才能稳定递推。

---

如果你也想掌握这题的另一个更常用解法（**栈 + 哨兵下标**，写起来更短且更直观），我也可以给你并对比两者优缺点。
