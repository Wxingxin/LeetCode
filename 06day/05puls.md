# 11

非常好！我们就专心盯着「链表的主干」是怎么一步一步变出来的——也就是：**链表的骨架（next 指针链）到底是怎么被重新拼接的**。

我们用最经典的例子：  
输入：**1 → 2 → 3 → 4 → 5**  
目标：**2 → 1 → 4 → 3 → 5**

下面给你看「主干变化」的 6 个关键帧（每一步只改 1～3 条指针），就像看动画慢动作一样。

### 初始状态（加了 dummy）
```
dummy → 1 → 2 → 3 → 4 → 5 → null
        ↑
       curr
```

### 第 1 次交换（处理 1 和 2）

执行三步翻转后，主干变成：
```
dummy → 2 → 1 → 3 → 4 → 5 → null
              ↑
             curr（准备处理下一对）
```

关键变化：
- dummy 原来指向 1 → 现在指向 2
- 2 原来指向 3 → 现在指向 1
- 1 原来指向 2 → 现在指向 3（接上后面的主干）

第一对交换完成，主干已经从 1-2 变成了 2-1

### 第 2 次交换（处理 3 和 4）

curr 现在在 1 上，执行三步翻转后，主干变成：
```
dummy → 2 → 1 → 4 → 3 → 5 → null
                    ↑
                   curr
```

关键变化：
- 1 原来指向 3 → 现在指向 4
- 4 原来指向 5 → 现在指向 3
- 3 原来指向 4 → 现在指向 5

第二对交换完成，主干又从 3-4 变成了 4-3

### 循环结束（只剩 5，不够一对了）

主干最终定型：
```
dummy → 2 → 1 → 4 → 3 → 5 → null
```

返回 dummy.next 就是：
```
2 → 1 → 4 → 3 → 5
```

### 主干变化全过程（只看骨架）

| 阶段               | 主干长这样（只看 next 链）                         |
|-------------------|---------------------------------------------------|
| 初始               | dummy → 1 → 2 → 3 → 4 → 5                         |
| 第一次交换后        | dummy → 2 → 1 → 3 → 4 → 5                         |
| 第二次交换后        | dummy → 2 → 1 → 4 → 3 → 5                         |
| 结束，返回 dummy.next | 2 → 1 → 4 → 3 → 5                                 |

可以看到：**整个链表主干就是被「局部地」一段一段翻转，每翻转一对，curr 就向前跳两格，继续处理下一对**。

### 再用一个更形象的“人拉手”比喻（主干视角）

想象 5 个人排成一队牵手：  
**dummy - 1 - 2 - 3 - 4 - 5**

每轮操作其实就是：
1. curr（前一个人）松开 1 的手，改牵 2 的手  
2. 2 松开后面人的手，改牵 1 的手  
3. 1 去牵原来 2 后面那个人（3）的手  

于是队伍瞬间变成：  
**dummy - 2 - 1 - 3 - 4 - 5**

curr 走到 1 的位置（现在是队伍中第 3 个人），重复上面动作，又变成：  
**dummy - 2 - 1 - 4 - 3 - 5**

这就是「主干」被不断重排的全过程！

### 总结：链表主干变化的核心规律
- 每轮只改动 3 条 next 指针
- 改完一对后，curr 向前移动 2 步（跳到刚交换好的第二个节点）
- 整个链表就像被「每两个人为一组」原地翻了个个儿
- 最后剩 0 或 1 个节点时自然不动

掌握了这个“主干变化动画”，你以后看到任何链表指针翻转题（比如 K 个一组翻转、反转整个链表、反转部分链表），都能在脑子里直接放电影了！

# 22

太好了！这才是最容易被忽略、但一旦彻底弄懂你就无敌的点——**指针 curr 到底是怎么一步一步“跳”过去的**。

我们就盯着 **curr 这个指针本身**，全程跟踪它在链表中的位置变化。

还是用最经典的例子：  
**1 → 2 → 3 → 4 → 5**

加上 dummy 后的完整链表是：  
**dummy → 1 → 2 → 3 → 4 → 5 → null**

### curr 的完整“人生轨迹”（6 个关键帧）

| 阶段                 | curr 此刻指向哪个节点？ | 节点的值 | 说明（curr 的角色）                                      | 链表当前样子（重点看 curr 位置）                  |
|----------------------|-------------------------|----------|---------------------------------------------------------|--------------------------------------------------|
| 0. 初始化            | dummy                   | 0        | curr 指向虚拟头结点                                     | curr<br>↓<br>dummy → 1 → 2 → 3 → 4 → 5           |
| 1. 第一次交换前      | dummy                   | 0        | 此时 curr 是「第1对（1和2）的前一个节点」                | curr<br>↓<br>dummy → 1 → 2 → 3 → 4 → 5           |
| 2. 第一次交换后<br>执行 curr = node1 | 1                       | 1        | 交换完后，curr 跳到「刚刚被交换的那一对的第二个节点」<br>（也就是现在排在后面的那个） | dummy → 2 → 1 → 3 → 4 → 5<br>        ↑<br>       curr |
| 3. 第二次交换前      | 1                       | 1        | 此时 curr 是「第2对（3和4）的前一个节点」                | dummy → 2 → 1 → 3 → 4 → 5<br>        ↑<br>       curr |
| 4. 第二次交换后<br>执行 curr = node1 | 3                       | 3        | 又跳到「刚刚被交换的那一对的第二个节点」                | dummy → 2 → 1 → 4 → 3 → 5<br>              ↑<br>             curr |
| 5. 循环结束判断      | 3                       | 3        | 检查 curr.next（=5） 和 curr.next.next（=null）<br>null 不满足条件，循环结束 | dummy → 2 → 1 → 4 → 3 → 5<br>              ↑<br>             curr |
| 6. 返回结果          | 不动了                  | -        | curr 最后停在原链表倒数第二个节点（如果是奇数长度）     | 最终返回 2 → 1 → 4 → 3 → 5                       |

### curr 的移动规律（超级口诀，背下来一辈子不忘）

**curr 的使命永远只有一个：  
“我永远指向 当前要处理的那一对节点的前一个节点”**

它的移动方式永远只有一句话：  
**每交换完一对，就把自己挪到「这对节点中现在排在后面的那个节点」上**  
也就是代码里这句：  
```js
curr = node1;   // node1 就是交换后排在后面的那个
```

所以 curr 的跳跃路径其实是：

```
dummy  →  1  →  3  →  (停下)
 (值0)    (值1)  (值3)
```

它永远跳过两个节点（步长为 2），但不是从头开始跳，而是从 dummy 开始，每轮跳到「上一对的尾巴」。

### 不同长度链表时 curr 的最终停留位置

| 原始链表长度 | curr 初始 | 第一次跳到 | 第二次跳到 | 第三次跳到 | 最终停在（值） | 规律总结                     |
|--------------|-----------|------------|------------|------------|----------------|------------------------------|
| 1 个节点     | dummy     | 不跳       | -          | -          | dummy (0)      | 停在 dummy                   |
| 2 个节点     | dummy     | 1          | 停         | -          | 原第1个节点    | 停在交换后的第二个节点       |
| 3 个节点     | dummy     | 1          | 停         | -          | 原第1个节点    | 停在交换后的第二个节点       |
| 4 个节点     | dummy     | 1          | 3          | 停         | 原第3个节点    | 停在最后交换对的第二个节点   |
| 5 个节点     | dummy     | 1          | 3          | 停         | 原第3个节点    | 同上                         |

**终极规律**：  
**curr 最后会停在「最后一次成功交换的那一对的第二个节点」上**  
如果一次都没交换（长度 ≤ 1），就停在 dummy。

### 一句话总结 curr 的变化过程

**curr 从 dummy 出发，每成功交换一对节点，就向前跳 2 格，永远站在「下一对要交换的节点的前一个位置」。直到后面不够两个节点了，就停下来。**

记住了 curr 的这套“跳跳舞”规律，你以后看任何分组翻转、间隔操作的链表题（比如每 k 个一组翻转），脑子里都能瞬间知道指针该怎么跳了！

需要我再给你画一个“curr 跳舞动画”纯文字版吗？或者直接来一道 K 个一组翻转让你现场感受一下？随时安排！