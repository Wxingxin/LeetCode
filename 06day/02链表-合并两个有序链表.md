将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]

太好了！我们来结合一个**完整具体案例**，从头到尾手把手走一遍这段代码的执行过程，让你彻底明白每一个指针在干嘛！

### 案例数据（经典面试例）

```js
l1: 1 → 3 → 5 → 8 → 9
l2: 2 → 4 → 6 → 7
```

目标：合并成 → `1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9`

### 初始状态图示

```
dummy(-1) → null
       ↑
   current

l1 → 1 → 3 → 5 → 8 → 9 → null
l2 → 2 → 4 → 6 → 7 → null
```

### 一步步执行过程（超级详细表格

| 步骤 | while 条件 | l1.val 和 l2.val 比较 | 选择哪个节点 | current.next 指向谁 | l1/l2 前进 | current 前进 | 当前新链表状态 |
|------|--------------------|------------------------|---------------|-------------------------|-------------|----------------|---------------|
| 初始 | true               | -                      | -             | -                       | -           | -              | dummy → null |
| 1    | true               | 1 ≤ 2                  | 选 l1 的 1     | current.next = 1        | l1 → 3      | current → 1     | dummy → 1 → null |
| 2    | true               | 3 > 2                  | 选 l2 的 2     | current.next = 2        | l2 → 4      | current → 2     | dummy → 1 → 2 → null |
| 3    | true               | 3 ≤ 4                  | 选 l1 的 3     | current.next = 3        | l1 → 5      | current → 3     | dummy → 1→2→3→null |
| 4    | true               | 5 > 4                  | 选 l2 的 4     | current.next = 4        | l2 → 6      | current → 4     | dummy → 1→2→3→4→null |
| 5    | true               | 5 ≤ 6                  | 选 l1 的 5     | current.next = 5        | l1 → 8      | current → 5     | dummy → 1→2→3→4→5→null |
| 6    | true               | 8 > 6                  | 选 l2 的 6     | current.next = 6        | l2 → 7      | current → 6     | dummy → 1→2→3→4→5→6→null |
| 7    | true               | 8 > 7                  | 选 l2 的 7     | current.next = 7        | l2 → null   | current → 7     | dummy → 1→2→3→4→5→6→7→null |
| 8    | false（l2 为 null）| 跳出 while             | -             | -                       | - | - | 当前状态：l1还有8→9，l2已空 |

### 跳出 while 后执行尾巴拼接

```js
if (l1 !== null) {
    current.next = l1;  // current 是节点7，把 l1 剩下的 8→9 直接接上！
}
```

结果：
```
dummy → 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → null
                                           ↑
                                       current
```

最后：
```js
return dummy.next;  // 跳过 dummy(-1)，返回节点1开始的链表
```

最终返回：`1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9`

### 为什么用 dummy 虚拟头节点？（超级重要！）

如果你不用 dummy，直接让 current = null 开始，会遇到一个很麻烦的问题：

```js
// 错误示范（第一次赋值时不知道 current.next 指向谁）
let current = null;
if (l1.val <= l2.val) {
    current = l1;         // 第一次赋值 ok
} else {
    current = l2;
}
current.next = ... // 下次还得判断 current 是否为 null，超级麻烦！
```

用了 dummy 以后：

```js
const dummy = new ListNode(-1);
let current = dummy;      // 一开始就有一个“地基”
current.next = 小的那一方; // 随时可以接，根本不用判断！
```

这就是为什么 99% 的面试答案都用 dummy —— **省心、简洁、无脑安全！**

### 终极记忆口诀（背下来，面试秒写）

```js
dummy做地基，current搬砖，
两个表都在，比较谁小先搬谁，
搬完当前指针往前挪一步，
一个表空了，剩下全接上，
最后返回dummy.next，完事！
```

### 更多边界案例验证（代码全都能过！）

| l1             | l2             | 结果                     |
|----------------|----------------|--------------------------|
| null           | 1→2→3         | 1→2→3                   |
| 1→2→3         | null           | 1→2→3                   |
| null           | null           | null                    |
| 1→3           | 2              | 1→2→3                   |
| 5              | 1→2→3→4        | 1→2→3→4→5               |

全部正确！

现在你已经完全掌握了这道题的灵魂！  
需要我再给你画一张彩色动态执行图，或者出 5 道进阶题练手吗？随时说！