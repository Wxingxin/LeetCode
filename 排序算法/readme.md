# 🔥 常见排序算法大全（最清晰版）

## 1. 冒泡排序（Bubble Sort）

**思想**：重复遍历数组，每次比较相邻两个元素，若顺序错误就交换。
**特点**：最大值会像“冒泡”一样逐步往后移动。

| 属性         | 值    |
| ------------ | ----- |
| 时间复杂度   | O(n²) |
| 空间复杂度   | O(1)  |
| 稳定排序     | 是    |
| 是否原地排序 | 是    |

**适用**：数据量小，或者需要稳定排序。

---

## 2. 选择排序（Selection Sort）

**思想**：每一轮从剩余元素中选择最小值，放到当前排好序的末尾。

| 属性         | 值    |
| ------------ | ----- |
| 时间复杂度   | O(n²) |
| 空间复杂度   | O(1)  |
| 稳定排序     | ❌ 否 |
| 是否原地排序 | 是    |

**适用**：对稳定性没有要求，能接受 O(n²) 情况的小数据量。

---

## 3. 插入排序（Insertion Sort）

**思想**：从左到右将元素逐个插入前面已排序的序列中。

| 属性         | 值                           |
| ------------ | ---------------------------- |
| 时间复杂度   | O(n²)，但几乎有序时可达 O(n) |
| 空间复杂度   | O(1)                         |
| 稳定排序     | 是                           |
| 是否原地排序 | 是                           |

**适用**：数据 **几乎有序** 时非常快。

---

## 4. 希尔排序（Shell Sort）

**思想**：对数组按照 gap 分组做插入排序，逐步缩小 gap。

| 属性         | 值                                          |
| ------------ | ------------------------------------------- |
| 时间复杂度   | 取决于 gap 序列（通常介于 O(n¹․³) ~ O(n²)） |
| 空间复杂度   | O(1)                                        |
| 稳定排序     | ❌ 否                                       |
| 是否原地排序 | 是                                          |

**适用**：比插入排序快，中等规模数据。

---

## 5. 归并排序（Merge Sort）

**思想**：分治，把数组不断二分，递归排序后再合并。

| 属性         | 值         |
| ------------ | ---------- |
| 时间复杂度   | O(n log n) |
| 空间复杂度   | O(n)       |
| 稳定排序     | 是         |
| 是否原地排序 | ❌ 否      |

**适用**：需要 **稳定排序** 且 **性能可靠** 的情况。

---

## 6. 快速排序（Quick Sort）

**思想**：选择基准 pivot，把小的放左边，大的放右边，递归排序。

| 属性           | 值                            |
| -------------- | ----------------------------- |
| 平均时间复杂度 | O(n log n)                    |
| 最坏时间复杂度 | O(n²)（退化情况，如已经有序） |
| 空间复杂度     | O(log n)                      |
| 稳定排序       | ❌ 否                         |
| 是否原地排序   | 基本是（取决于实现）          |

**适用**：最常用的排序算法，实际表现通常最快。

---

## 7. 堆排序（Heap Sort）

**思想**：将数组构造成最大堆，不断取出堆顶最大值。

| 属性         | 值         |
| ------------ | ---------- |
| 时间复杂度   | O(n log n) |
| 空间复杂度   | O(1)       |
| 稳定排序     | ❌ 否      |
| 是否原地排序 | 是         |

**适用**：空间要求低，性能稳定，不需要稳定性。

---

## 8. 计数排序（Counting Sort）

**思想**：统计每个数出现的次数，从而直接确定它的位置。

| 属性         | 值                     |
| ------------ | ---------------------- |
| 时间复杂度   | O(n + k)，k 为数值范围 |
| 空间复杂度   | O(k)                   |
| 稳定排序     | 是                     |
| 是否原地排序 | ❌ 否                  |

**适用**：当数字范围比较小（例如成绩 0~100）时非常快。

---

## 9. 桶排序（Bucket Sort）

**思想**：把数据分散到多个桶中，每个桶内部再排序（通常用插入或快排）。

| 属性         | 值                    |
| ------------ | --------------------- |
| 时间复杂度   | 平均 O(n)，最坏 O(n²) |
| 空间复杂度   | 高                    |
| 稳定排序     | 要看桶内排序          |
| 是否原地排序 | 否                    |

**适用**：数据均匀分布时非常高效。

---

## 10. 基数排序（Radix Sort）

**思想**：按个位、十位、百位……（或按 bit），多轮“稳定排序”。

| 属性         | 值                                 |
| ------------ | ---------------------------------- |
| 时间复杂度   | O(d × (n + k))，d 为位数，k 为基数 |
| 空间复杂度   | O(n + k)                           |
| 稳定排序     | 是                                 |
| 是否原地排序 | 否                                 |

**适用**：对整数、定长字符串排序非常快。

---

# ⭐ 各排序算法对比总结表

| 排序 | 平均期望   | 最坏情况   | 稳定吗？ | 空间复杂度 | 特点           |
| ---- | ---------- | ---------- | -------- | ---------- | -------------- |
| 冒泡 | O(n²)      | O(n²)      | ✔        | O(1)       | 简单稳定       |
| 选择 | O(n²)      | O(n²)      | ✖        | O(1)       | 交换次数少     |
| 插入 | O(n²)      | O(n²)      | ✔        | O(1)       | 近乎有序时最好 |
| 希尔 | O(n¹․³)    | O(n²)      | ✖        | O(1)       | 改良插入       |
| 快排 | O(n log n) | O(n²)      | ✖        | O(log n)   | 平均最快       |
| 归并 | O(n log n) | O(n log n) | ✔        | O(n)       | 稳定、高效     |
| 堆排 | O(n log n) | O(n log n) | ✖        | O(1)       | 空间最优       |
| 计数 | O(n+k)     | O(n+k)     | ✔        | O(k)       | k 小超快       |
| 桶排 | O(n)       | O(n²)      | 看情况   | 高         | 分布均匀超快   |
| 基数 | O(d(n+k))  | O(d(n+k))  | ✔        | O(n+k)     | 非比较排序     |

---

# 如果需要，我可以继续提供：

✔ 所有排序的 JavaScript 实现代码
✔ 动画图示（可视化每种排序的过程）
✔ 一张“如何选择排序算法”思维导图
✔ 帮你写排序算法复习笔记 / 面试速记版

只要告诉我你需要哪一种即可！
